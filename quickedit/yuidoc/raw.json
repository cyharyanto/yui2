{"majorversion": 2, "filemap": {"QuickEdit.js": {"classlist": ["YAHOO.widget.QuickEditDataTable"], "name": "QuickEdit.js", "module": "DataTable"}, "classmap.js": {"name": "classmap.js", "classlist": [], "module": "DataTable", "guessedname": "classMap", "guessedtype": "property", "property": "classMap"}}, "modules": {"DataTable": {"description": "QuickEdit extension to YUI 2 DataTable\nAuthor: lindalj@yahoo-inc.com / John Lindal", "submodules": ["Quick Edit"], "classlist": ["YAHOO.widget.QuickEditDataTable"], "filelist": ["QuickEdit.js", "classmap.js"], "subdata": {"Quick Edit": {"name": "YAHOO.widget.QuickEditDataTable", "description": "QuickEdit extension to YUI 2 DataTable\nAuthor: lindalj@yahoo-inc.com / John Lindal"}}, "name": "DataTable"}}, "classmap": {"YAHOO.widget.QuickEditDataTable": {"name": "YAHOO.widget.QuickEditDataTable", "constructors": [{"params": [{"type": "HTMLElement", "name": "elContainer", "description": "  Container element for the TABLE."}, {"type": "Object[]", "name": "aColumnDefs", "description": "  Array of object literal Column definitions."}, {"type": "YAHOO.util.DataSource", "name": "oDataSource", "description": "  DataSource instance."}, {"type": "object", "name": "oConfigs", "description": "  (optional) Object literal of configuration values."}], "description": "<p>The QuickEditDataTable class extends the DataTable class to\nprovide QuickEdit mode.  (It could just as easily extend\nScrollingDataTable.)  QuickEdit mode allows the user to edit all the\nvalues that are visible in the table, controlled by the column\nconfiguration.  Each editable cell contains an input field.  If the\nuser decides to save the changes, then you can extract the changes\nby calling <code>getQuickEditChanges()</code>.</p>\n<p>For a column to be editable in QuickEdit mode, the column\nconfiguration must include <code>quickEdit</code>.  The contents of\nthis object define the column's behavior in QuickEdit mode.</p>\n<p>If a column should not be editable, but needs to be formatted\ndifferently in QuickEdit mode, then you must define qeFormatter in\nthe column configuration. This is simply a normal cell formatter\nfunction that will be used in QuickEdit mode.  The static functions\n<code>readonly*QuickEditFormatter</code> provide examples.</p>\n<p>The following configuration can be provided as part of\nquickEdit:</p>\n<dl>\n<dt>copyDown</dt><dd>If true, the top cell in the column will have a\nbutton to copy the value down to the rest of the rows.</dd>\n<dt>formatter</dt><dd>The cell formatter which will render an\nappropriate form field: &lt;input type=\"text\"&gt;, &lt;textarea&gt;,\nor &lt;select&gt;.</dd>\n<dt>validation</dt><dd>Validation configuration for every field in\nthe column.</dd>\n</dl>\n<p>The following configuration can be provided as part of\nquickEdit.validation:</p>\n<dl>\n<dt>css</dt><dd>CSS classes encoding basic validation rules:\n<dl>\n<dt><code>yiv-required</code></dt>\n<dd>Value must not be empty.</dd>\n<dt><code>yiv-length:[x,y]</code></dt>\n<dd>String must be at least x characters and at most y characters.\nAt least one of x and y must be specified.</dd>\n<dt><code>yiv-integer:[x,y]</code></dt>\n<dd>The integer value must be at least x and at most y.\nx and y are both optional.</dd>\n<dt><code>yiv-decimal:[x,y]</code></dt>\n<dd>The decimal value must be at least x and at most y.  Exponents are\nnot allowed.  x and y are both optional.</dd>\n</dl>\n</dd>\n<dt>fn</dt><dd>A function that will be called with the DataTable as\nits scope and the cell's form element as the argument. Return true\nif the value is valid. Otherwise, call\nthis.displayQuickEditMessage(...) to display an error and return\nfalse.</dd>\n<dt>msg</dt><dd>A map of types to messages that will be displayed\nwhen a basic or regex validation rule fails. The valid types are:\nrequired, min_length, max_length, integer, decimal, and regex.\nThere is no default for type regex, so you must specify a message if\nyou configure a regex validation.</dd>\n<dt>regex</dt><dd>Regular expression that the value must satisfy in\norder to be considered valid.</dd>\n</dl>\n<p>Custom QuickEdit Formatters</p>\n<p>To write a custom cell formatter for QuickEdit mode, you must\nstructure the function as follows:</p>\n<pre>\nfunction myQuickEditFormatter(el, oRecord, oColumn, oData) {\n&nbsp;&nbsp;var markup =\n&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type=\"text\" class=\"{yiv} yui-quick-edit yui-quick-edit-key:{key}\"/&gt;' +\n&nbsp;&nbsp;&nbsp;&nbsp;YAHOO.widget.QuickEditDataTable.MARKUP_QE_ERROR_DISPLAY;\n&nbsp;&nbsp;&nbsp;&nbsp;el.innerHTML = lang.substitute(markup, {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key: oColumn.key,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yiv: oColumn.quickEdit.validation ? (oColumn.quickEdit.validation.css || '') : ''\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;el.firstChild.value = extractMyEditableValue(oData);\n&nbsp;&nbsp;&nbsp;&nbsp;YAHOO.widget.QuickEditDataTable.copyDownFormatter.apply(this, arguments);\n};\n</pre>\n<p>You can use textarea or select instead of input, but you can only\ncreate a single field.</p>\n<p><code>extractMyEditableValue</code> does not have to be a separate\nfunction nor must it be limited to using only oData. The work should\nnormally be done inline in the formatter function, but the name of\nthe sample function makes the point clear.</p>"}], "namespace": "YAHOO.widget", "module": "DataTable", "guessedname": "QuickEditDataTable", "methods": {"clearQuickEditMessages": {"description": "Clear all validation messages in QuickEdit mode.", "guessedname": "clearQuickEditMessages", "guessedtype": "function"}, "startQuickEdit": {"description": "Switch to QuickEdit mode.  Columns that have quickEdit defined will\nbe editable.", "guessedname": "startQuickEdit", "guessedtype": "function"}, "_getQuickEditElementStatus": {"guessedname": "_getQuickEditElementStatus", "params": [{"type": "Element", "name": "e", "description": "  form field"}, {"type": "RegExp", "name": "r", "description": "  regex to match against className"}], "description": "Return the status of the field.", "private": "", "guessedtype": "function"}, "textQuickEditFormatter": {"static": "", "description": "Called with exactly the same arguments as any other cell\nformatter, this function displays an input field.", "guessedname": "textQuickEditFormatter", "guessedtype": "function"}, "readonlyLinkQuickEditFormatter": {"static": "", "description": "Called with exactly the same arguments as any other cell\nformatter, this function displays an email address without the\nanchor tag.  Use this as the column's qeFormatter if the column\nshould not be editable in QuickEdit mode.", "guessedname": "readonlyEmailQuickEditFormatter", "guessedtype": "function"}, "_moveQuickEditFocus": {"private": "", "description": "Shift the focus up/down within a column.", "guessedname": "_moveQuickEditFocus", "guessedtype": "function"}, "_validateQuickEditElements": {"return": {"type": "boolean", "description": "true if all validation checks pass"}, "description": "Validate the given form fields.", "private": "", "params": [{"type": "Array", "name": "e", "description": "  Array of form fields."}], "guessedname": "_validateQuickEditElements", "guessedtype": "function"}, "_quickEditCopyDown": {"guessedname": "_quickEditCopyDown", "params": [{"type": "Event", "name": "e", "description": "  triggering event"}, {"type": "Element", "name": "cell", "description": "  cell from which to copy"}], "description": "Copy value from first cell to all other cells in the column.", "private": "", "guessedtype": "function"}, "textareaQuickEditFormatter": {"static": "", "description": "Called with exactly the same arguments as any other cell\nformatter, this function displays a textarea field.", "guessedname": "textareaQuickEditFormatter", "guessedtype": "function"}, "getQuickEditChanges": {"return": {"type": "mixed", "description": "array if all validation passed, false otherwise"}, "description": "Return the changed values.  For each row, an object is created\nwith only the changed values.  The object keys are the column keys.", "guessedname": "getQuickEditChanges", "guessedtype": "function"}, "copyDownFormatter": {"static": "", "description": "Called with exactly the same arguments as a normal cell\nformatter, this function inserts a \"Copy down\" button if the\ncell is in the first row of the DataTable.  Call this at the end\nof your QuickEdit formatter.", "guessedname": "copyDownFormatter", "guessedtype": "function"}, "displayQuickEditMessage": {"params": [{"type": "Element", "name": "e", "description": "  form field"}, {"type": "String", "name": "msg", "description": "  message to display"}, {"type": "String", "name": "type", "description": "  message type: error, warn, success, info"}, {"type": "boolean", "name": "scroll", "description": "  If false, does not scroll, even if this is the first message to display."}], "description": "Display a message for a QuickEdit field.  If an existing message with\na higher precedence is already visible, it will not be replaced.", "guessedname": "displayQuickEditMessage", "guessedtype": "function"}, "cancelQuickEdit": {"description": "Switch out of QuickEdit mode.  THIS DISCARDS ALL DATA!  If you\nwant to save the data, call getQuickEditChanges() BEFORE calling\nthis function.", "guessedname": "cancelQuickEdit", "guessedtype": "function"}, "validateQuickEdit": {"return": {"type": "boolean", "description": "true if all validation checks pass"}, "description": "Validate the QuickEdit data.", "guessedname": "validateQuickEdit", "guessedtype": "function"}}, "extends": "YAHOO.widget.DataTable", "superclass": "YAHOO.widget.DataTable", "file": "QuickEdit.js", "guessedtype": "function", "shortname": "QuickEditDataTable", "configs": {"YAHOO.widget.QuickEditDataTable.status_order": {"type": "{Array}", "static": "", "description": "<p>Names of supported status values, highest precedence first.  Default:\n<code>[ 'error', 'warn', 'success', 'info' ]</code></p>\n<p>This is static because it links to CSS rules that define the\nappearance of each status type:  .formmgr-has{status}</p>", "guessedname": "status_order", "guessedtype": "property"}, "YAHOO.widget.QuickEditDataTable.Strings": {"type": "{Object}", "static": "", "description": "<p>Map of localizable strings used by pre-validation.</p>\n<dl>\n<dt>required_string</dt>\n<dd>Displayed when <code>yiv-required</code> fails on an input field.</dd>\n<dt>required_menu</dt>\n<dd>Displayed when <code>yiv-required</code> fails on a select element.</dd>\n<dt>length_too_short, length_too_long, length_out_of_range</dt>\n<dd>Displayed when <code>yiv-length</code> fails on an input field.</dd>\n<dt>integer, integer_too_small, integer_too_large, integer_out_of_range</dt>\n<dd>Displayed when <code>yiv-integer</code> fails on an input field.</dd>\n<dt>decimal, decimal_too_small, decimal_too_large, decimal_out_of_range</dt>\n<dd>Displayed when <code>yiv-decimal</code> fails on an input field.</dd>\n</dl>", "guessedname": "Strings", "guessedtype": "property"}}, "description": "<p>The QuickEditDataTable class extends the DataTable class to\nprovide QuickEdit mode.  (It could just as easily extend\nScrollingDataTable.)  QuickEdit mode allows the user to edit all the\nvalues that are visible in the table, controlled by the column\nconfiguration.  Each editable cell contains an input field.  If the\nuser decides to save the changes, then you can extract the changes\nby calling <code>getQuickEditChanges()</code>.</p>\n<p>For a column to be editable in QuickEdit mode, the column\nconfiguration must include <code>quickEdit</code>.  The contents of\nthis object define the column's behavior in QuickEdit mode.</p>\n<p>If a column should not be editable, but needs to be formatted\ndifferently in QuickEdit mode, then you must define qeFormatter in\nthe column configuration. This is simply a normal cell formatter\nfunction that will be used in QuickEdit mode.  The static functions\n<code>readonly*QuickEditFormatter</code> provide examples.</p>\n<p>The following configuration can be provided as part of\nquickEdit:</p>\n<dl>\n<dt>copyDown</dt><dd>If true, the top cell in the column will have a\nbutton to copy the value down to the rest of the rows.</dd>\n<dt>formatter</dt><dd>The cell formatter which will render an\nappropriate form field: &lt;input type=\"text\"&gt;, &lt;textarea&gt;,\nor &lt;select&gt;.</dd>\n<dt>validation</dt><dd>Validation configuration for every field in\nthe column.</dd>\n</dl>\n<p>The following configuration can be provided as part of\nquickEdit.validation:</p>\n<dl>\n<dt>css</dt><dd>CSS classes encoding basic validation rules:\n<dl>\n<dt><code>yiv-required</code></dt>\n<dd>Value must not be empty.</dd>\n<dt><code>yiv-length:[x,y]</code></dt>\n<dd>String must be at least x characters and at most y characters.\nAt least one of x and y must be specified.</dd>\n<dt><code>yiv-integer:[x,y]</code></dt>\n<dd>The integer value must be at least x and at most y.\nx and y are both optional.</dd>\n<dt><code>yiv-decimal:[x,y]</code></dt>\n<dd>The decimal value must be at least x and at most y.  Exponents are\nnot allowed.  x and y are both optional.</dd>\n</dl>\n</dd>\n<dt>fn</dt><dd>A function that will be called with the DataTable as\nits scope and the cell's form element as the argument. Return true\nif the value is valid. Otherwise, call\nthis.displayQuickEditMessage(...) to display an error and return\nfalse.</dd>\n<dt>msg</dt><dd>A map of types to messages that will be displayed\nwhen a basic or regex validation rule fails. The valid types are:\nrequired, min_length, max_length, integer, decimal, and regex.\nThere is no default for type regex, so you must specify a message if\nyou configure a regex validation.</dd>\n<dt>regex</dt><dd>Regular expression that the value must satisfy in\norder to be considered valid.</dd>\n</dl>\n<p>Custom QuickEdit Formatters</p>\n<p>To write a custom cell formatter for QuickEdit mode, you must\nstructure the function as follows:</p>\n<pre>\nfunction myQuickEditFormatter(el, oRecord, oColumn, oData) {\n&nbsp;&nbsp;var markup =\n&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type=\"text\" class=\"{yiv} yui-quick-edit yui-quick-edit-key:{key}\"/&gt;' +\n&nbsp;&nbsp;&nbsp;&nbsp;YAHOO.widget.QuickEditDataTable.MARKUP_QE_ERROR_DISPLAY;\n&nbsp;&nbsp;&nbsp;&nbsp;el.innerHTML = lang.substitute(markup, {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key: oColumn.key,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yiv: oColumn.quickEdit.validation ? (oColumn.quickEdit.validation.css || '') : ''\n&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;el.firstChild.value = extractMyEditableValue(oData);\n&nbsp;&nbsp;&nbsp;&nbsp;YAHOO.widget.QuickEditDataTable.copyDownFormatter.apply(this, arguments);\n};\n</pre>\n<p>You can use textarea or select instead of input, but you can only\ncreate a single field.</p>\n<p><code>extractMyEditableValue</code> does not have to be a separate\nfunction nor must it be limited to using only oData. The work should\nnormally be done inline in the formatter function, but the name of\nthe sample function makes the point clear.</p>"}}, "version": "1.0.0", "namespaces": ["YAHOO.widget"]}